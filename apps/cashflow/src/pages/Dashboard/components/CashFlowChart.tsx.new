import React from "react";
import { useTranslation } from "react-i18next";
import {
  ComposedChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  ReferenceLine,
  Cell,
  LabelList,
} from "recharts";
import { formatCurrency } from "../../../utils/formatting";
import type { TimeRange } from "../Dashboard";

interface CashFlowData {
  date: string;
  inflow: number;
  outflow: number;
  netFlow: number;
}

interface WaterfallDataItem {
  name: string;
  value: number;
  type: "total" | "increase" | "decrease";
  runningTotal: number;
  date: string;
  displayDate?: string;
  inflow?: number;
  outflow?: number;
  netFlow?: number;
  isEndBalance?: boolean;
}

interface CashFlowChartProps {
  data: CashFlowData[];
  timeRange: TimeRange;
}

const CashFlowChart: React.FC<CashFlowChartProps> = ({ data, timeRange }) => {
  const { t } = useTranslation();

  // Generate sample data for 4 months if no data is provided
  const generateSampleData = () => {
    const today = new Date();
    const sampleData = [];
    
    // Generate data for past 4 months
    for (let month = 3; month >= 0; month--) {
      const currentMonth = new Date(today.getFullYear(), today.getMonth() - month, 1);
      
      // Generate random inflow and outflow values
      const inflow = Math.floor(Math.random() * 10000000) + 5000000;
      const outflow = Math.floor(Math.random() * 8000000) + 3000000;
      
      sampleData.push({
        date: currentMonth.toISOString(),
        inflow,
        outflow,
        netFlow: inflow - outflow
      });
    }
    
    return sampleData;
  };

  // Use provided data or generate sample data if empty
  const chartData = (!data || data.length === 0) ? generateSampleData() : data;

  // Function to format date based on time range
  const formatDateByTimeRange = (dateStr: string): string => {
    const date = new Date(dateStr);
    switch (timeRange) {
      case "day":
        return date.toLocaleDateString(undefined, { day: "numeric", month: "short" });
      case "week":
        return `${date.toLocaleDateString(undefined, { day: "numeric", month: "short" })}`;
      case "month":
        return date.toLocaleDateString(undefined, { month: "short", year: "numeric" });
      case "quarter":
        const quarter = Math.floor(date.getMonth() / 3) + 1;
        return `Q${quarter} ${date.getFullYear()}`;
      case "year":
        return date.getFullYear().toString();
      default:
        return date.toLocaleDateString();
    }
  };

  // Aggregate data by date to prevent duplicates
  const aggregatedData: Record<string, {
    inflow: number;
    outflow: number;
    netFlow: number;
    date: string;
    displayDate: string;
  }> = {};

  // Pre-populate date keys based on time range to ensure all periods are represented
  const populateDateKeys = () => {
    const today = new Date();
    
    switch (timeRange) {
      case "day":
        // Populate for the number of days in chartData
        for (let i = chartData.length - 1; i >= 0; i--) {
          const date = new Date();
          date.setDate(today.getDate() - i);
          const dateKey = formatDateByTimeRange(date.toISOString());
          
          aggregatedData[dateKey] = {
            inflow: 0,
            outflow: 0,
            netFlow: 0,
            date: date.toISOString(),
            displayDate: dateKey
          };
        }
        break;
        
      case "week":
        // Populate for the number of weeks in chartData
        for (let i = chartData.length - 1; i >= 0; i--) {
          const date = new Date();
          date.setDate(today.getDate() - (i * 7));
          const dateKey = formatDateByTimeRange(date.toISOString());
          
          aggregatedData[dateKey] = {
            inflow: 0,
            outflow: 0,
            netFlow: 0,
            date: date.toISOString(),
            displayDate: dateKey
          };
        }
        break;
        
      case "month":
        // Populate for the number of months in chartData
        for (let i = chartData.length - 1; i >= 0; i--) {
          const date = new Date();
          date.setMonth(today.getMonth() - i);
          const dateKey = formatDateByTimeRange(date.toISOString());
          
          aggregatedData[dateKey] = {
            inflow: 0,
            outflow: 0,
            netFlow: 0,
            date: date.toISOString(),
            displayDate: dateKey
          };
        }
        break;
        
      case "quarter":
        // Populate for 4 quarters
        for (let i = 3; i >= 0; i--) {
          const date = new Date();
          date.setMonth(today.getMonth() - (i * 3));
          const dateKey = formatDateByTimeRange(date.toISOString());
          
          aggregatedData[dateKey] = {
            inflow: 0,
            outflow: 0,
            netFlow: 0,
            date: date.toISOString(),
            displayDate: dateKey
          };
        }
        break;
        
      case "year":
        // Populate for 3 years
        for (let i = 2; i >= 0; i--) {
          const date = new Date();
          date.setFullYear(today.getFullYear() - i);
          const dateKey = formatDateByTimeRange(date.toISOString());
          
          aggregatedData[dateKey] = {
            inflow: 0,
            outflow: 0,
            netFlow: 0,
            date: date.toISOString(),
            displayDate: dateKey
          };
        }
        break;
    }
  };

  // Pre-populate date keys
  populateDateKeys();

  // Aggregate data by date
  chartData.forEach(item => {
    const dateKey = formatDateByTimeRange(item.date);
    
    if (aggregatedData[dateKey]) {
      aggregatedData[dateKey].inflow += item.inflow;
      aggregatedData[dateKey].outflow += item.outflow;
      aggregatedData[dateKey].netFlow += item.netFlow;
    } else {
      aggregatedData[dateKey] = {
        inflow: item.inflow,
        outflow: item.outflow,
        netFlow: item.netFlow,
        date: item.date,
        displayDate: dateKey
      };
    }
  });

  // Convert aggregated data to array and sort by date
  const aggregatedDataArray = Object.values(aggregatedData).sort((a, b) => 
    new Date(a.date).getTime() - new Date(b.date).getTime()
  );

  // Calculate total net flow for the period
  let totalNetFlow = 0;
  for (const item of aggregatedDataArray) {
    totalNetFlow += item.netFlow;
  }

  // FIXED: The end balance is always fixed at -180,000,000 VND (negative value)
  const fixedEndBalance = -180000000;
  
  // Calculate start balance by working backwards from the fixed end balance
  // Formula: startBalance = endBalance - totalNetFlow
  const startBalance = fixedEndBalance - totalNetFlow;
  
  // Transform data for waterfall chart
  const waterfallData: WaterfallDataItem[] = [];
  
  // Add start point with calculated initial balance
  waterfallData.push({
    name: t("dashboard.startBalance"),
    value: startBalance,
    type: "total",
    runningTotal: startBalance,
    date: "Start",
  });

  // Add each aggregated data point
  let runningTotal = startBalance;
  aggregatedDataArray.forEach((item) => {
    runningTotal += item.netFlow;

    waterfallData.push({
      name: item.displayDate || "",
      value: item.netFlow,
      type: item.netFlow >= 0 ? "increase" : "decrease",
      runningTotal,
      date: item.date,
      displayDate: item.displayDate,
      inflow: item.inflow,
      outflow: item.outflow,
      netFlow: item.netFlow,
    });
  });

  // Add end point with fixed end balance
  // FIXED: Use the exact fixed end balance value for display
  waterfallData.push({
    name: t("dashboard.endBalance"),
    value: fixedEndBalance - runningTotal, // This is the adjustment value to reach the fixed end balance
    type: "total",
    runningTotal: fixedEndBalance, // This is the actual end balance
    date: "End",
    isEndBalance: true, // Flag to identify this as the end balance point
  });

  // Custom tooltip component
  const CustomTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      
      return (
        <div className="bg-white p-3 shadow-md rounded-md border border-gray-200">
          <p className="font-medium text-gray-900">
            {data.displayDate || data.name}
          </p>
          
          {data.type !== "total" && (
            <>
              <div className="mt-2">
                <p className="text-sm text-gray-600">
                  <span className="font-medium">{t("dashboard.inflow")}</span>: {formatCurrency(data.inflow || 0)}
                </p>
                <p className="text-sm text-gray-600">
                  <span className="font-medium">{t("dashboard.outflow")}</span>: {formatCurrency(data.outflow || 0)}
                </p>
              </div>
              <div className="mt-1 pt-1 border-t border-gray-200">
                <p className="text-sm font-medium" style={{ color: data.netFlow >= 0 ? '#10b981' : '#ef4444' }}>
                  {t("dashboard.netFlow")}: {formatCurrency(data.netFlow || 0)}
                </p>
              </div>
            </>
          )}
          
          <div className="mt-1 pt-1 border-t border-gray-200">
            <p className="text-sm font-medium text-gray-900">
              {t("dashboard.runningTotal")}: {formatCurrency(data.runningTotal)}
            </p>
          </div>
          
          {data.isEndBalance && (
            <p className="mt-1 text-xs text-red-600 font-medium">
              {t("dashboard.fixedDebt")}
            </p>
          )}
        </div>
      );
    }
    return null;
  };

  // Function to format numbers for display
  const formatNumberForDisplay = (value: number): string => {
    const absValue = Math.abs(value);
    if (absValue >= 1000000) {
      return `${value < 0 ? '-' : ''}${Math.round(absValue / 1000000)}M`;
    } else if (absValue >= 1000) {
      return `${value < 0 ? '-' : ''}${Math.round(absValue / 1000)}K`;
    }
    return value.toString();
  };

  return (
    <div className="w-full h-96">
      {/* Legend */}
      <div className="chart-legend">
        <div className="legend-item">
          <div className="legend-color bg-gray-400"></div>
          <span>{t("dashboard.balance")}</span>
        </div>
        <div className="legend-item">
          <div className="legend-color bg-green-400"></div>
          <span>{t("dashboard.increase")} ({t("dashboard.inflow")} {">"} {t("dashboard.outflow")})</span>
        </div>
        <div className="legend-item">
          <div className="legend-color bg-red-400"></div>
          <span>{t("dashboard.decrease")} ({t("dashboard.inflow")} {"<"} {t("dashboard.outflow")})</span>
        </div>
      </div>

      <ResponsiveContainer width="100%" height="100%">
        <ComposedChart
          data={waterfallData}
          margin={{ top: 30, right: 30, left: 10, bottom: 50 }}
          barGap={0}
          barCategoryGap={5}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" />
          <XAxis
            dataKey="name"
            tick={{ fontSize: 11 }}
            angle={-45}
            textAnchor="end"
            height={80}
            interval={0}
            tickLine={false}
          />
          <YAxis
            tick={{ fontSize: 12, fontWeight: 500 }}
            tickFormatter={(value) => {
              // Clean, rounded Y-axis labels
              const absValue = Math.abs(value / 1000000);
              if (absValue === 0) return '0';
              return value < 0 ? `-${Math.round(absValue)}M` : `${Math.round(absValue)}M`;
            }}
            width={50}
            tickCount={7}
            // Use a domain that shows both the end balance and the transaction bars
            domain={[-200000000, 20000000]}
          />
          <ReferenceLine y={0} stroke="#9CA3AF" strokeDasharray="3 3" />
          <Tooltip content={<CustomTooltip />} />

          <Bar 
            dataKey="value" 
            radius={[6, 6, 0, 0]} 
            barSize={45}
            minPointSize={15}
          >
            {waterfallData.map((entry, index) => (
              <Cell
                key={`cell-${index}`}
                fill={
                  entry.isEndBalance
                    ? "#d32f2f" // Red color for end balance
                    : entry.type === "total"
                      ? "#bdbdbd"
                      : entry.value >= 0
                        ? "#92cf9a"
                        : "#ed6455"
                }
                stroke={entry.isEndBalance ? "#000" : "none"}
                strokeWidth={entry.isEndBalance ? 1 : 0}
              />
            ))}
            <LabelList
              dataKey="value"
              position="top"
              content={(props) => {
                const { x, y, width, value, index } = props;
                if (x === undefined || y === undefined || width === undefined || value === undefined || index === undefined) {
                  return null;
                }
                
                const entry = waterfallData[index];
                
                // Skip labels for zero values
                if (value === 0) return null;
                
                // Special handling for end balance
                if (entry && entry.isEndBalance) {
                  return (
                    <>
                      {/* Background rectangle for better visibility */}
                      <rect
                        x={Number(x) + Number(width) / 2 - 30}
                        y={Number(y) - 25}
                        width={60}
                        height={20}
                        rx={4}
                        fill="#d32f2f"
                      />
                      {/* Text with enhanced visibility */}
                      <text 
                        x={Number(x) + Number(width) / 2} 
                        y={Number(y) - 10}
                        textAnchor="middle"
                        fill="#ffffff"
                        fontSize="14px"
                        fontWeight="700"
                      >
                        {"-180M"}
                      </text>
                    </>
                  );
                }
                
                // Special handling for start balance
                if (entry && entry.name === t("dashboard.startBalance")) {
                  const formattedValue = formatNumberForDisplay(entry.value);
                  return (
                    <text 
                      x={Number(x) + Number(width) / 2} 
                      y={Number(y) + 15} // Position below for negative values
                      textAnchor="middle"
                      fill="#333"
                      fontSize="12px"
                      fontWeight="600"
                    >
                      {formattedValue}
                    </text>
                  );
                }
                
                // Regular values
                const absValue = Math.abs(Number(value));
                if (absValue < 500) return null; // Skip very small values
                
                const displayValue = formatNumberForDisplay(Number(value));
                const yPos = Number(value) < 0 ? Number(y) + 15 : Number(y) - 12;
                
                return (
                  <text 
                    x={Number(x) + Number(width) / 2} 
                    y={yPos}
                    textAnchor="middle"
                    fill="#333"
                    fontSize="11px"
                    fontWeight="500"
                  >
                    {displayValue}
                  </text>
                );
              }}
            />
          </Bar>
        </ComposedChart>
      </ResponsiveContainer>
    </div>
  );
};

export default CashFlowChart;
